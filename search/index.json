[{"content":"一、概念 1. 大数据处理流程 上图是一个简化的大数据处理流程图，大数据处理的主要流程包括数据收集、数据存储、数据处理、数据应用等主要环节。下面我们逐一对各个环节所需要的技术栈进行讲解：\n1.1 数据收集 大数据处理的第一步，第一种是通过 Sqoop 或者 Cannal 等工具进行定时抽取或者实时同步；第二种是各种埋点日志，通过 Flume 进行实时收集。\n大数据处理的第一步是数据的收集。现在的中大型项目通常采用微服务架构进行分布式部署，所以数据的采集需要在多台服务器上进行，且采集过程不能影响正常业务的开展。基于这种需求，就衍生了多种日志收集工具，如 Flume 、Logstash、Kibana 等，它们都能通过简单的配置完成复杂的数据收集和数据聚合。\n1.2 数据存储 大数据处理的第二步，将数据存储到 HDFS 中，实时日志流情况下通过 Kafka 输出给后面的流式计算引擎。\n收集到数据后，下一个问题就是：数据该如何进行存储？通常最为熟知是 MySQL、Oracle 等传统的关系型数据库，它们的优点是能够快速存储结构化的数据，并支持随机访问。但大数据的数据结构通常是半结构化（如日志数据）、甚至是非结构化的（如视频、音频数据），为了解决海量半结构化和非结构化数据的存储，衍生了 Hadoop HDFS 、KFS、GFS 等分布式文件系统，它们都能够支持结构化、半结构和非结构化数据的存储，并可以通过增加机器进行横向扩展。\n分布式文件系统完美地解决了海量数据存储的问题，但是一个优秀的数据存储系统需要同时考虑数据存储和访问两方面的问题，比如你希望能够对数据进行随机访问，这是传统的关系型数据库所擅长的，但却不是分布式文件系统所擅长的，那么有没有一种存储方案能够同时兼具分布式文件系统和关系型数据库的优点，基于这种需求，就产生了 HBase、MongoDB。\n1.3 数据分析 大数据的核心环节，包括离线处理和流处理两种方式，对应的计算引擎包括 MapReduce、Spark、Flink 等，处理完的结果会保存到已经提前设计好的数据仓库中，或者 HBase、Redis、RDBMS 等各种存储系统上。\n大数据处理最重要的环节就是数据分析，数据分析通常分为两种：批处理和流处理。\n批处理：对一段时间内海量的离线数据进行统一的处理，对应的处理框架有 Hadoop MapReduce、Spark、Flink 等； 流处理：对运动中的数据进行处理，即在接收数据的同时就对其进行处理，对应的处理框架有 Storm、Spark Streaming、Flink Streaming 等。 批处理和流处理各有其适用的场景，时间不敏感或者硬件资源有限，可以采用批处理；时间敏感和及时性要求高就可以采用流处理。随着服务器硬件的价格越来越低和大家对及时性的要求越来越高，流处理越来越普遍，如股票价格预测和电商运营数据分析等。\n上面的框架都是需要通过编程来进行数据分析，那么如果你不是一个后台工程师，是不是就不能进行数据的分析了？当然不是，大数据是一个非常完善的生态圈，有需求就有解决方案。为了能够让熟悉 SQL 的人员也能够进行数据的分析，查询分析框架应运而生，常用的有 Hive 、Spark SQL 、Flink SQL、 Pig、Phoenix 等。这些框架都能够使用标准的 SQL 或者 类 SQL 语法灵活地进行数据的查询分析。这些 SQL 经过解析优化后转换为对应的作业程序来运行，如 Hive 本质上就是将 SQL 转换为 MapReduce 作业，Spark SQL 将 SQL 转换为一系列的 RDDs 和转换关系（transformations），Phoenix 将 SQL 查询转换为一个或多个 HBase Scan。\n1.4 数据应用 应用场景：数据可视化、业务决策、推荐算法优化、机器学习\u0026hellip;\n数据分析完成后，接下来就是数据应用的范畴，这取决于你实际的业务需求。比如你可以将数据进行可视化展现，或者将数据用于优化你的推荐算法，这种运用现在很普遍，比如短视频个性化推荐、电商商品推荐、头条新闻推荐等。当然你也可以将数据用于训练你的机器学习模型，这些都属于其他领域的范畴，都有着对应的框架和技术栈进行处理，这里就不一一赘述。\n1.5 其他框架 上面是一个标准的大数据处理流程所用到的技术框架。但是实际的大数据处理流程比上面复杂很多，针对大数据处理中的各种复杂问题分别衍生了各类框架：\n单机的处理能力都是存在瓶颈的，所以大数据框架都是采用集群模式进行部署，为了更方便的进行集群的部署、监控和管理，衍生了 Ambari、Cloudera Manager 等集群管理工具； 想要保证集群高可用，需要用到 ZooKeeper ，ZooKeeper 是最常用的分布式协调服务，它能够解决大多数集群问题，包括首领选举、失败恢复、元数据存储及其一致性保证。同时针对集群资源管理的需求，又衍生了 Hadoop YARN ; 复杂大数据处理的另外一个显著的问题是，如何调度多个复杂的并且彼此之间存在依赖关系的作业？基于这种需求，产生了 Azkaban 和 Oozie 等工作流调度框架； 大数据流处理中使用的比较多的另外一个框架是 Kafka，它可以用于消峰，避免在秒杀等场景下并发数据对流处理程序造成冲击； 另一个常用的框架是 Sqoop ，主要是解决了数据迁移的问题，它能够通过简单的命令将关系型数据库中的数据导入到 HDFS 、Hive 或 HBase 中，或者从 HDFS 、Hive 导出到关系型数据库上。\n1.6 框架分类 日志收集框架：Flume、Logstash、Filebeat\n分布式文件存储系统：Hadoop HDFS\n数据库系统：Mongodb、HBase\n分布式计算框架：\n批处理框架：Hadoop MapReduce 流处理框架：Storm 混合处理框架：Spark、Flink 查询分析框架：Hive 、Spark SQL 、Flink SQL、 Pig、Phoenix\n集群资源管理器：Hadoop YARN\n分布式协调服务：Zookeeper\n数据迁移工具：Sqoop\n任务调度框架：Azkaban、Oozie\n集群部署和监控：Ambari、Cloudera Manager\n2. 数据仓库 2.1 什么是数据仓库？ 在计算中，数据仓库（DW或DWH）也称为企业数据仓库（EDW），是用于报告和数据分析的系统，被视为商业智能的核心组件。DWs从一个或多个不同源的综合数据的中央储存库。他们将当前和历史数据存储在一个地方，用于为整个企业的工作人员创建分析报告。\n3. OLTP与OLAP的区别 OLTP与OLAP是数据仓库的两种操作方式。 当今的数据处理大致可分为两大类，联机事务处理OLTP（on-line transaction processing） 和联机分析处理OLAP（on-line analytical processing)。\nOLTP是传统关系型数据库的主要应用，用来执行一些基本的、日常的事务处理，比如数据库记录的增、删、改、查等等。而OLAP则是分布式数据库的主要应用，它对实时性要求不高，但处理的数据量大，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果，通常应用于复杂的动态报表系统上。\n4. ETL与DM的区别 ETL/Extraction-Transformation-Loading——用于完成DB到DW的数据转存，它将DB中的某一个时间点的状态，“抽取”出来，根据DW的存储模型要求，“转换”一下数据格式，然后再“加载”到DW的一个过程，这里需要强调的是，DB的模型是ER模型，遵从范式化设计原则，而DW的数据模型是雪花型结构或者星型结构，用的是面向主题，面向问题的设计思路，所以DB和DW的模型结构不同，需要进行转换。\nDM/Data Mining/数据挖掘——这个挖掘，不是简单的统计了，他是根据概率论的或者其他的统计学原理，将DW中的大数据量进行分析，找出我们不能直观发现的规律。\n5. 行式存储与列式存储 列式存储是指一列中的数据在存储介质中是连续存储的；\n行式存储是指一行中的数据在存储介质中是连续存储的。 什么时候使用列式存储，什么时候使用行式存储？\n如果一个OLPA类型查询，在海量数据行中，只关心几列数据，效率就比较低了。这种情况列存储就有很大优势。同样如果每次查询设计的数据量较小，或者大部分查询都需要整行数据，行存储就有优势。\n如果需要关注整张表或者大部分数据，不是单独几列而且关注内容不需要聚集运算，推荐行式存储；\n如果主要关注大量数据中某几列内容，或者要频繁聚集，然后对聚集后数据进行数据分析，推荐列式存储。\n6. HDFS（分布式文件系统） HDFS(Hadoop Distribute File System)，是适用于大的数据集的支持高吞吐和高容错的运行在通用机器上的分布式系统。Hapoop就是使用HDFS来存储海量数据，使用MapReduce来处理数据。但是hdfs主要是实现批量数据的处理，并且通过顺序方式访问数据，如果要查找数据必须搜索整个数据集，如果要随机读取数据，效率很低。\n7. MapReduce 上文多次提出，以MapReduce提供计算能力。MapReduce是一个软件框架，基于该框架能够容易地编写应用程序，这些应用程序能够运行在由上千个商用机器组成的大集群上，并以一种可靠的，具有容错能力的方式并行地处理上TB级别的海量数据集\nMapReduce擅长处理大数据。MapReduce的思想就是“分而治之”。Mapper负责“分”，即把复杂的任务分解为若干个“简单的任务”来处理。“简单的任务”包含三层含义：一是数据或计算的规模相对原任务要大大缩小；二是就近计算原则，即任务会分配到存放着所需数据的节点上进行计算；三是这些小任务可以并行计算，彼此间几乎没有依赖关系。Reducer负责对map阶段的结果进行汇总。\n二、特点 大数据特点\n①Volume：数据量大，包括采集、存储和计算的量都非常大。大数据的起始计量单位至少是P（1000个T）、E（100万个T）或Z（10亿个T）。\n②Variety：种类和来源多样化。包括结构化、半结构化和非结构化数据，具体表现为网络日志、音频、视频、图片、地理位置信息等等，多类型的数据对数据的处理能力提出了更高的要求。\n③Value：数据价值密度相对较低，或者说是浪里淘沙却又弥足珍贵。随着互联网以及物联网的广泛应用，信息感知无处不在，信息海量，但价值密度较低，如何结合业务逻辑并通过强大的机器算法来挖掘数据价值，是大数据时代最需要解决的问题。\n④Velocity：数据增长速度快，处理速度也快，时效性要求高。比如搜索引擎要求几分钟前的新闻能够被用户查询到，个性化推荐算法尽可能要求实时完成推荐。这是大数据区别于传统数据挖掘的显著特征。\n⑤Veracity：数据的准确性和可信赖度，即数据的质量。\n参考：\nhttps://github.com/heibaiying https://javabetter.cn/xuexiluxian/bigdata.html#%E5%85%B3%E4%BA%8E%E5%A4%A7%E6%95%B0%E6%8D%AE\n","date":"2025-01-01T11:17:11+08:00","permalink":"https://h-yx-blog.github.io/p/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/","title":"大数据基础"},{"content":"Anaconda是一个环境管理工具，每一个环境可以理解为一个房间，每个环境存放着不同的包，互不干扰\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 创建环境：conda create -n 环境名字 python=3.10 复制虚拟环境：conda create -n 副本虚拟环境名 --clone 虚拟环境名 进入环境：activate 环境名字 （Linux环境下要用：conda activate 环境名字） 查看有哪些环境： conda env list 查看conda信息：conda info -v 安装包：conda install django=2.0 最后django=2.0是指包名和版本号 查看都有哪些包 conda list 更新包：conda update 包名 删除包：conda remove 包名 搜索包：conda search package-name，可以模糊搜索 环境切换： activate 环境名 删除环境：conda remove -n 环境名 --all 最后表示把环境里面的包也一起删除 ","date":"2024-12-28T11:20:54+08:00","permalink":"https://h-yx-blog.github.io/p/anaconda%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/","title":"Anaconda基础使用"},{"content":"Hugo语法 1、本地启动Hugo博客 进入博客根目录 比如我的是：D:\\blog\\hugo_extended_withdeploy_0.140.1_windows-amd64\\yuta-blog\n1 hugo server -D 2、创建文章 同样进入 D:\\blog\\hugo_extended_withdeploy_0.140.1_windows-amd64\\yuta-blog\n1 hugo new content post/文件名称/index.md 文件名称后面就是博客的文章名称，最后一定是要 index.md\n3、提交代码 同样 进入 D:\\blog\\hugo_extended_withdeploy_0.140.1_windows-amd64\\yuta-blog\n1 2 3 git add . git commit -m \u0026#34;本次提交的变更\u0026#34; git push ","date":"2024-12-27T17:16:55+08:00","permalink":"https://h-yx-blog.github.io/p/hugo-grammar/","title":"Hugo Grammar"},{"content":"","date":"2024-12-27T02:04:07+08:00","permalink":"https://h-yx-blog.github.io/p/linux/","title":"Linux"},{"content":"","date":"2024-12-27T01:50:08+08:00","permalink":"https://h-yx-blog.github.io/p/java/","title":"Java"},{"content":"Python入门语法 一、数据类型 常见数据类型 类型 描述 说明 数字（Number） 支持 •整数（int） •浮点数（float） •复数（complex） •布尔（bool） 整数（int），如：10、-10 浮点数（float），如：13.14、-13.14 复数（complex），如：4+3j，以j结尾表示复 数\n布尔（bool）表达现实生活中的逻辑，即真和假，True表示真，False表示假。 True本质上是一个数字记作1，False记作0 字符串（String） 描述文本的一种数据类型 字符串（string）由任意数量的字符组成 列表（List） 有序的可变序列 Python中使用最频繁的数据类型，可有序记录一堆数据 元组（Tuple） 有序的不可变序列 可有序记录一堆不可变的Python数据集合 集合（Set） 无序不重复集合 可无序记录一堆不重复的Python数据集合 字典（Dictionary） 无序Key-Value集合 可无序记录一堆Key-Value型的Python数据集合 type() 使用type()方法可以查看当前变量的数据类型\n数据类型转换 语句(函数) 说明 int(x) 将x转换为一个整数 float(x) 将x转换为一个浮点数 str(x) 将对象 x 转换为字符串 注意：浮点数转整数会丢失精度，即会丢失小数部分\n命名规范 见名知意 下划线命名法 （由于历史原因，python更推荐使用下划线命名） 英文字母全小写 在命名时不允许与关键字相同，python关键字如下\n运算符 运算符 描述 实例 + 加 两个对象相加 a + b 输出结果 30 - 减 得到负数或是一个数减去另一个数 a - b 输出结果 -10 * 乘 两个数相乘或是返回一个被重复若干次的字符串 a * b 输出结果 200 / 除 b / a 输出结果 2 // 取整除 返回商的整数部分 9//2 输出结果 4 , 9.0//2.0 输出结果 4.0 % 取余 返回除法的余数 b % a 输出结果 0 * * 指数 a * *b 为10的20次方， 输出结果 100000000000000000000 常见数据类型的格式化 格式符号 转化 %s 将内容转换成字符串，放入占位位置 %d 将内容转换成整数，放入占位位置 %f 将内容转换成浮点型，放入占位位置 格式化的精度控制\n可以使用辅助符号\u0026quot;m.n\u0026quot;来控制数据的宽度和精度\nm，控制宽度，要求是数字（很少使用）,设置的宽度小于数字自身，不生效 .n，控制小数点精度，要求是数字，会进行小数的四舍五入 示例：\n%5d：表示将整数的宽度控制在5位，如数字11，被设置为5d，就会变成：[空格][空格][空格]11，用三个空格补足宽度。 %5.2f：表示将宽度控制为5，将小数点精度设置为2 小数点和小数部分也算入宽度计算。如，对11.345设置了%7.2f 后，结果是：[空格][空格]11.35。2个空格补足宽度，小数部分限制2位精度后，四舍五入为 .35\n%.2f：表示不限制宽度，只设置小数点精度为2，如11.345设置%.2f后，结果是11.35 例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 name = \u0026#34;黄永禧\u0026#34; setup_year = 2024 stock_price = 19.99 message = \u0026#34;%s，成立于：%d，我今天的股价是：%f\u0026#34; % (name, setup_year, stock_price) print(message) num1 = 11 num2 = 11.345 print(\u0026#34;数字11宽度限制5，结果是：%5d\u0026#34; % num1) print(\u0026#34;数字11宽度限制1，结果是：%1d\u0026#34; % num1) print(\u0026#34;数字11.345宽度限制7，小数精度2，结果是：%7.2f\u0026#34; % num2) print(\u0026#34;数字11.345不限制，小数精度2，结果是：%.2f\u0026#34; % num2) 字符串格式化常用的方法：**f\u0026#34;{占位}\u0026#34;** name = \u0026#34;黄永禧\u0026#34; set_up_year = 2024 stock_price = 19.99 print(f\u0026#34;我是{name}，我成立于：{set_up_year}年，我今天的股价是：{stock_price}\u0026#34;) 二、判断语句 1.写法 if 条件1:\n条件1满足应做的事情\n条件1满足应做的事情\nelif 条件2:\n条件2满足应做的事情\n条件2满足应做的事情\nelif 条件N:\n条件N满足应做的事情\n条件N满足应做的事情\nelse:\n所有条件都不满足应做的事情\n所有条件都不满足应做的事情\n注意：① if elif else的结尾都要有分号 : 来结尾\n② python是使用缩进来控制代码块的归属\n③elif可以写多个\n④if语句可以嵌套，嵌套时注意缩进来表示代码块的归属\n三、循环语句 1.while循环 while 条件:\n条件满足时，执行的逻辑1\n条件满足时，执行的逻辑2\n条件满足时，执行的逻辑N\n2.for循环 for 临时变量 in 待处理数据集:\n满足循环条件时进行的逻辑处理\n3.range语句 range(num) # 获取一个从0开始，到num结束的数字序列（不含num本身）。如range(5)取得的数据是：[0, 1, 2, 3, 4]\nrange(num1,num2) # 获得一个从num1开始，到num2结束的数字序列（不含num2本身）。如，range(5, 10)取得的数据是：[5, 6, 7, 8, 9]\nrange(num1,num2,step) # 获得一个从num1开始，到num2结束的数字序列（不含num2本身），数字之间的步长，以step为准（step默认为1）。如，range(5, 10, 2)取得的数据是：[5, 7, 9]\n4.变量作用域 第二个print语句中，是可以访问到i变量的。但是：出于规范，不建议这样访问\n1 2 3 4 5 6 for i in range(5) print(i) print(i) 5.continue 和break python在循环中与java一样，可以使用continue跳过当次循环，或使用break跳出整个循环\n四.Python函数 1.函数定义 def 函数名(传入参数1,传入参数2):\n函数体\nreturn 返回值\n注意：\n① 参数如不需要，可以省略\n② 返回值如不需要，可以省略\n③ 函数必须先定义后使用\n如果函数没有返回值，其实是返回None类型\n在if判断中，None等同于False\n2.函数说明文档 当要对函数做注释说明时，一般规范如下\ndef add(x, y):\n\u0026quot;\u0026quot;\u0026quot;\nadd函数可以接收2个参数，进行2数相加的功能\n:param x: 形参x表示相加的其中一个数字\n:param y: 形参y表示相加的另一个数字\n:return: 返回值是2数相加的结果\n\u0026quot;\u0026quot;\u0026quot;\nresult = x + y\nprint(f\u0026quot;2数相加的结果是：{result}\u0026quot;)\nreturn result\n3.函数多个返回值 返回多个返回值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def test_return(): return 1, \u0026#34;hello\u0026#34;, True mylist = test_return() print(mylist) x, y, z = test_return() print(x) print(y) print(z) 注意：\n① 按照返回值的顺序，写对应顺序的多个变量接收即可\n② 变量之间用逗号隔开\n③ 支持不同类型的数据return\n4.函数多种传参方式 4.1 位置参数 1 2 3 4 5 6 7 8 9 10 11 调用函数时根据函数定义的参数位置来传递参数。传递的参数和定义的参数的顺序及个数必须一致 def user_info(name, age, gender): print(f\u0026#34;姓名是:{name}, 年龄是:{age}, 性别是:{gender}\u0026#34;) # 位置参数 - 默认使用形式 user_info(\u0026#39;小明\u0026#39;, 20, \u0026#39;男\u0026#39;) 4.2 关键字参数 函数调用时通过“键=值”形式传递参数，可以让函数更加清晰、容易使用，同时也清除了参数的顺序需求.\n函数调用时，如果有位置参数时，位置参数必须在关键字参数的前面，但关键字参数之间不存在先后顺序\n1 2 3 4 5 6 7 8 9 10 def user_info(name, age, gender): print(f\u0026#34;姓名是:{name}, 年龄是:{age}, 性别是:{gender}\u0026#34;) user_info(name=\u0026#39;小王\u0026#39;, age=11, gender=\u0026#39;女\u0026#39;) user_info(age=10, gender=\u0026#39;女\u0026#39;, name=\u0026#39;肖肖\u0026#39;) # 可以不按照参数的定义顺序传参 user_info(\u0026#39;甜甜\u0026#39;, gender=\u0026#39;女\u0026#39;, age=9) 4.3 不定长参数 不定长参数也叫可变参数. 用于不确定调用的时候会传递多少个参数(不传参也可以)的场景.\n类型一：位置传递\n如下代码，传进的所有参数都会被args变量收集，它会根据传进参数的位置合并为一个元组(tuple)，args是元组类型，这就是位置传递\n1 2 3 4 5 6 7 8 9 10 # 不定长 - 位置不定长, *号 # 不定长定义的形式参数会作为元组存在，接收不定长数量的参数传入 def user_info( *args): print(f\u0026#34;args参数的类型是：{type(args)}，内容是:{args}\u0026#34;) user_info(1, 2, 3, \u0026#39;小明\u0026#39;, \u0026#39;男孩\u0026#39;) 类型二：关键字传递\n参数是“键=值”形式的情况下, 所有的“键=值”都会被kwargs接受, 同时会根据“键=值”组成字典.\n1 2 3 4 5 6 7 8 # 不定长 - 关键字不定长, * *号 ，可理解为字典的不定长 def user_info( * *kwargs): print(f\u0026#34;args参数的类型是：{type(kwargs)}，内容是:{kwargs}\u0026#34;) user_info(name=\u0026#39;小王\u0026#39;, age=11, gender=\u0026#39;男孩\u0026#39;) 4.4. 缺省参数 缺省参数也叫默认参数，用于定义函数，为参数提供默认值，调用函数时可不传该默认参数的值（注意：所有位置参数必须出现在默认参数前，包括函数定义和调用）.\n函数调用时，如果为缺省参数传值则修改默认参数值, 否则使用这个默认值\n1 2 3 4 5 6 7 8 def user_info(name, age, gender=\u0026#39;女\u0026#39;): print(f\u0026#34;姓名是:{name}, 年龄是:{age}, 性别是:{gender}\u0026#34;) user_info(\u0026#39;小天\u0026#39;, 13) user_info(\u0026#39;小天\u0026#39;, 13, \u0026#39;男\u0026#39;) 5.global关键字 如下所示， testB 函数内部的 num = 200 是定义了一个局部变量，并没有真正修改到全局变量num的值，所以最好的print语句结果为200\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 num = 200 def test_a(): print(f\u0026#34;test_a: {num}\u0026#34;) def test_b(): num = 500 # 局部变量 print(f\u0026#34;test_b: {num}\u0026#34;) test_a() # 结果为200 test_b() # 结果为500 print(num) #结果为200 如果想修改全局变量num的值，可以用global关键字来声明 num = 200 def test_a(): print(f\u0026#34;test_a: {num}\u0026#34;) def test_b(): global num # 设置内部定义的变量为全局变量 num = 500 print(f\u0026#34;test_b: {num}\u0026#34;) test_a() #结果为200 test_b() #结果为500 print(num) #结果为500 6.匿名函数 6.1 函数作为参数传递\n定义一个函数，接收另一个函数作为传入参数 1 2 3 4 5 6 7 8 def test_func(compute): result = compute(1, 2) # 确定compute是函数 print(f\u0026#34;compute参数的类型是:{type(compute)}\u0026#34;) print(f\u0026#34;计算结果：{result}\u0026#34;) 定义一个函数，准备作为参数传入另一个函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def compute(x, y): return x + y # 调用，并传入函数 test_func(compute) 6.2 lambda匿名函数 定义语法 lambda 传入参数 : 函数体 # 定义一个函数，接受其它函数输入 def test_func(compute): result = compute(1, 2) print(f\u0026#34;结果是:{result}\u0026#34;) # 通过lambda匿名函数的形式，将匿名函数作为参数传入 def add(x, y): return x + y test_func(add) test_func(lambda x, y: x + y) 五、数据容器 5.1 list列表 5.1.1 列表的定义\n1 2 3 4 5 6 7 8 9 10 11 12 13 # 普通列表 my_list = [\u0026#34;我是字符串\u0026#34;, 666, True] # 嵌套列表 my_list = [ [1, 2, 3], [4, 5, 6]] #空列表 my_list = [] my_list = list() 5.1.2 列表的下标索引\n用下标进行元素索引\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 my_list = [\u0026#34;Tom\u0026#34;, \u0026#34;Lily\u0026#34;, \u0026#34;Rose\u0026#34;] # 列表[下标索引], 从前向后从0开始，每次+1， 从后向前从-1开始，每次-1 print(my_list[0]) print(my_list[1]) print(my_list[2]) # 取出嵌套列表的元素 my_list = [ [1, 2, 3], [4, 5, 6]] print(my_list[1][1]) 5.1.3 list常用操作\n编号 使用方式 作用 1 列表.append(元素) 向列表中追加一个元素 2 列表.extend(容器) 将数据容器的内容依次取出，追加到列表尾部 3 列表.insert(下标, 元素) 在指定下标处，插入指定的元素 4 del 列表[下标] 删除列表指定下标元素 5 列表.pop(下标) 删除列表指定下标元素 6 列表.remove(元素) 从前向后，删除此元素第一个匹配项 7 列表.clear() 清空列表 8 列表.count(元素) 统计此元素在列表中出现的次数 9 列表.index(元素) 查找指定元素在列表的下标 找不到报错ValueError 10 len(列表) 统计容器内有多少元素 5.1.4 列表的特点\n可以容纳多个元素（上限为2 * *63-1、9223372036854775807个） 可以容纳不同类型的元素（混装） 数据是有序存储的（有下标序号） 允许重复数据存在 可以修改（增加或删除元素等） 5.2 tuple元祖 元组一旦定义完成，就不可修改；当元组只有一个数据，这个数据后面要添加逗号 如 ： my_tuple = (\u0026lsquo;hello\u0026rsquo;, )\n元组可以如下三种定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 t1 = (1, \u0026#34;Hello\u0026#34;, True) t2 = () t3 = tuple() # 定义单个元素的元素 t4 = (\u0026#34;hello\u0026#34;, ) # 元组的嵌套 t5 = ( (1, 2, 3), (4, 5, 6) ) # 下标索引去取出内容 num = t5[1][2] # 元组的操作：index查找方法 t6 = (\u0026#34;茂佳科技\u0026#34;, \u0026#34;茂佳程序员\u0026#34;, \u0026#34;Python\u0026#34;) index = t6.index(\u0026#34;茂佳程序员\u0026#34;) print(f\u0026#34;在元组t6中查找茂佳程序员，的下标是：{index}\u0026#34;) # 元组的操作：count统计方法 t7 = (\u0026#34;茂佳科技\u0026#34;, \u0026#34;茂佳程序员\u0026#34;, \u0026#34;茂佳程序员\u0026#34;, \u0026#34;茂佳程序员\u0026#34;, \u0026#34;Python\u0026#34;) num = t7.count(\u0026#34;茂佳程序员\u0026#34;) print(f\u0026#34;在元组t7中统计茂佳程序员的数量有：{num}个\u0026#34;) # 元组的操作：len函数统计元组元素数量 t8 = (\u0026#34;茂佳科技\u0026#34;, \u0026#34;茂佳程序员\u0026#34;, \u0026#34;茂佳程序员\u0026#34;, \u0026#34;茂佳程序员\u0026#34;, \u0026#34;Python\u0026#34;) num = len(t8) print(f\u0026#34;t8元组中的元素有：{num}个\u0026#34;) # 元组的遍历：while index = 0 while index \u0026lt; len(t8): print(f\u0026#34;元组的元素有：{t8[index]}\u0026#34;) # 至关重要 index += 1 # 元组的遍历：for for element in t8: print(f\u0026#34;2元组的元素有：{element}\u0026#34;) # 定义一个元组,里面有list元素，list元素是可以修改的 t9 = (1, 2, [\u0026#34;itmoka\u0026#34;, \u0026#34;itcast\u0026#34;]) print(f\u0026#34;t9的内容是：{t9}\u0026#34;) t9[2][0] = \u0026#34;茂佳程序员\u0026#34; t9[2][1] = \u0026#34;茂佳科技\u0026#34; print(f\u0026#34;t9的内容是：{t9}\u0026#34;) 元祖操作\n编号 方法 作用 1 index() 查找某个数据，如果数据存在返回对应的下标，否则报错 2 count() 统计某个数据在当前元组出现的次数 3 len(元组) 统计元组内的元素个数 元祖的特点\n可以容纳多个数据 可以容纳不同类型的数据（混装） 数据是有序存储的（下标索引） 允许重复数据存在 不可以修改（增加或删除元素等） 支持for循环 5.3 str 字符串 5.3.1 字符串操作\n编号 操作 说明 1 字符串[下标] 根据下标索引取出特定位置字符 2 字符串.index(字符串） 查找给定字符的第一个匹配项的下标 3 字符串.replace(字符串1, 字符串2) 将字符串内的全部字符串1，替换为字符串2 不会修改原字符串，而是得到一个新的 4 字符串.split(字符串) 按照给定字符串，对字符串进行分隔 不会修改原字符串，而是得到一个新的列表 5 字符串.strip() 字符串.strip(字符串) 移除首尾的空格和换行符或指定字符串 6 字符串.count(字符串) 统计字符串内某字符串的出现次数 7 len(字符串) 统计字符串的字符个数 5.3.2 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 my_str = \u0026#34;itmoka and itcast\u0026#34; # 通过下标索引取值 value = my_str[2] value2 = my_str[-16] print(f\u0026#34;从字符串{my_str}取下标为2的元素，值是：{value},取下标为-16的元素。值是：{value2}\u0026#34;) # 不允许修改 # my_str[2] = \u0026#34;H\u0026#34; # index方法 value = my_str.index(\u0026#34;and\u0026#34;) print(f\u0026#34;在字符串{my_str}中查找and，其起始下标是：{value}\u0026#34;) # replace方法，得到的是个新的字符串，老的字符串还是没变的 new_my_str = my_str.replace(\u0026#34;it\u0026#34;, \u0026#34;程序\u0026#34;) print(f\u0026#34;将字符串{my_str}，进行替换后得到：{new_my_str}\u0026#34;) # split方法 my_str = \u0026#34;hello python itmoka itcast\u0026#34; my_str_list = my_str.split(\u0026#34; \u0026#34;) print(f\u0026#34;将字符串{my_str}进行split切分后得到：{my_str_list}, 类型是：{type(my_str_list)}\u0026#34;) # strip方法 my_str = \u0026#34; itmoka and itcast \u0026#34; new_my_str = my_str.strip() # 不传入参数，去除首尾空格 print(f\u0026#34;字符串{my_str}被strip后，结果：{new_my_str}\u0026#34;) my_str = \u0026#34;12itmoka and itcast21\u0026#34; new_my_str = my_str.strip(\u0026#34;12\u0026#34;) print(f\u0026#34;字符串{my_str}被strip(\u0026#39;12\u0026#39;)后，结果：{new_my_str}\u0026#34;) # 统计字符串中某字符串的出现次数, count my_str = \u0026#34;itmoka and itcast\u0026#34; count = my_str.count(\u0026#34;it\u0026#34;) print(f\u0026#34;字符串{my_str}中it出现的次数是：{count}\u0026#34;) # 统计字符串的长度, len() num = len(my_str) print(f\u0026#34;字符串{my_str}的长度是：{num}\u0026#34;) 5.3.3 字符串的特点\n只可以存储字符串 长度任意（取决于内存大小） 支持下标索引 允许重复字符串存在 不可以修改（增加或删除元素等） 支持for循环 5.4 set 集合 5.4.1 集合操作\n编号 操作 说明 1 集合.add(元素) 集合内添加一个元素 2 集合.remove(元素) 移除集合内指定的元素 3 集合.pop() 从集合中随机取出一个元素 4 集合.clear() 将集合清空 5 集合1.difference(集合2) 得到一个新集合，内含2个集合的差集 原有的2个集合内容不变 6 集合1.difference_update(集合2) 在集合1中，删除集合2中存在的元素 集合1被修改，集合2不变 7 集合1.union(集合2) 得到1个新集合，内含2个集合的全部元素 原有的2个集合内容不变 8 len(集合) 得到一个整数，记录了集合的元素数量 5.4.2 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 # 定义集合 my_set = {\u0026#34;茂佳科技\u0026#34;, \u0026#34;茂佳程序员\u0026#34;, \u0026#34;itmoka\u0026#34;, \u0026#34;茂佳科技\u0026#34;, \u0026#34;茂佳程序员\u0026#34;, \u0026#34;itmoka\u0026#34;, \u0026#34;茂佳科技\u0026#34;, \u0026#34;茂佳程序员\u0026#34;, \u0026#34;itmoka\u0026#34;} my_set_empty = set() # 定义空集合 print(f\u0026#34;my_set的内容是：{my_set}, 类型是：{type(my_set)}\u0026#34;) print(f\u0026#34;my_set_empty的内容是：{my_set_empty}, 类型是：{type(my_set_empty)}\u0026#34;) # 添加新元素 my_set.add(\u0026#34;Python\u0026#34;) my_set.add(\u0026#34;茂佳科技\u0026#34;) # print(f\u0026#34;my_set添加元素后结果是：{my_set}\u0026#34;) # 移除元素 my_set.remove(\u0026#34;茂佳程序员\u0026#34;) print(f\u0026#34;my_set移除茂佳程序员后，结果是：{my_set}\u0026#34;) # 随机取出一个元素 my_set = {\u0026#34;茂佳科技\u0026#34;, \u0026#34;茂佳程序员\u0026#34;, \u0026#34;itmoka\u0026#34;} element = my_set.pop() print(f\u0026#34;集合被取出元素是：{element}, 取出元素后：{my_set}\u0026#34;) # 清空集合, clear my_set.clear() print(f\u0026#34;集合被清空啦，结果是：{my_set}\u0026#34;) # 取2个集合的差集 set1 = {1, 2, 3} set2 = {1, 5, 6} set3 = set1.difference(set2) print(f\u0026#34;取出差集后的结果是：{set3}\u0026#34;) print(f\u0026#34;取差集后，原有set1的内容：{set1}\u0026#34;) print(f\u0026#34;取差集后，原有set2的内容：{set2}\u0026#34;) # 消除2个集合的差集 set1 = {1, 2, 3} set2 = {1, 5, 6} set1.difference_update(set2) print(f\u0026#34;消除差集后，集合1结果：{set1}\u0026#34;) print(f\u0026#34;消除差集后，集合2结果：{set2}\u0026#34;) # 2个集合合并为1个 set1 = {1, 2, 3} set2 = {1, 5, 6} set3 = set1.union(set2) print(f\u0026#34;2集合合并结果：{set3}\u0026#34;) print(f\u0026#34;合并后集合1：{set1}\u0026#34;) print(f\u0026#34;合并后集合2：{set2}\u0026#34;) # 统计集合元素数量len() set1 = {1, 2, 3, 4, 5, 1, 2, 3, 4, 5} num = len(set1) print(f\u0026#34;集合内的元素数量有：{num}个\u0026#34;) # 集合的遍历 # 集合不支持下标索引，不能用while循环 # 可以用for循环 set1 = {1, 2, 3, 4, 5,10,7 } for element in set1: print(f\u0026#34;集合的元素有：{element}\u0026#34;) 5.4.3 集合的特点\n可以容纳多个数据 可以容纳不同类型的数据（混装） 数据是无序存储的（不支持下标索引） 不允许重复数据存在 可以修改（增加或删除元素等） 支持for循环 5.5 dict 字典 5.5.1 字典操作\n编号 操作 说明 1 字典[Key] 获取指定Key对应的Value值 2 字典[Key] = Value 添加或更新键值对 3 字典.pop(Key) 取出Key对应的Value并在字典内删除此Key的键值对 4 字典.clear() 清空字典 5 字典.keys() 获取字典的全部Key，可用于for循环遍历字典 6 len(字典) 计算字典内的元素数量 5.5.2 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 ① 定义字典 # 定义字典 my_dict1 = {\u0026#34;王力鸿\u0026#34;: 99, \u0026#34;周杰轮\u0026#34;: 88, \u0026#34;林俊节\u0026#34;: 77} # 定义空字典 my_dict2 = {} my_dict3 = dict() print(f\u0026#34;字典1的内容是：{my_dict1}, 类型：{type(my_dict1)}\u0026#34;) print(f\u0026#34;字典2的内容是：{my_dict2}, 类型：{type(my_dict2)}\u0026#34;) print(f\u0026#34;字典3的内容是：{my_dict3}, 类型：{type(my_dict3)}\u0026#34;) # 定义重复Key的字典 my_dict1 = {\u0026#34;王力鸿\u0026#34;: 99, \u0026#34;王力鸿\u0026#34;: 88, \u0026#34;林俊节\u0026#34;: 77} print(f\u0026#34;重复key的字典的内容是：{my_dict1}\u0026#34;) # 从字典中基于Key获取Value my_dict1 = {\u0026#34;王力鸿\u0026#34;: 99, \u0026#34;周杰轮\u0026#34;: 88, \u0026#34;林俊节\u0026#34;: 77} score = my_dict1[\u0026#34;王力鸿\u0026#34;] print(f\u0026#34;王力鸿的考试分数是：{score}\u0026#34;) score = my_dict1[\u0026#34;周杰轮\u0026#34;] print(f\u0026#34;周杰轮的考试分数是：{score}\u0026#34;) # 定义嵌套字典 stu_score_dict = { \u0026#34;王力鸿\u0026#34;: { \u0026#34;语文\u0026#34;: 77, \u0026#34;数学\u0026#34;: 66, \u0026#34;英语\u0026#34;: 33 }, \u0026#34;周杰轮\u0026#34;: { \u0026#34;语文\u0026#34;: 88, \u0026#34;数学\u0026#34;: 86, \u0026#34;英语\u0026#34;: 55 }, \u0026#34;林俊节\u0026#34;: { \u0026#34;语文\u0026#34;: 99, \u0026#34;数学\u0026#34;: 96, \u0026#34;英语\u0026#34;: 66 } } print(f\u0026#34;学生的考试信息是：{stu_score_dict}\u0026#34;) # 从嵌套字典中获取数据 # 看一下周杰轮的语文信息 score = stu_score_dict[\u0026#34;周杰轮\u0026#34;][\u0026#34;语文\u0026#34;] print(f\u0026#34;周杰轮的语文分数是：{score}\u0026#34;) score = stu_score_dict[\u0026#34;林俊节\u0026#34;][\u0026#34;英语\u0026#34;] print(f\u0026#34;林俊节的英语分数是：{score}\u0026#34;) ②字典操作 my_dict = {\u0026#34;周杰轮\u0026#34;: 99, \u0026#34;林俊节\u0026#34;: 88, \u0026#34;张学油\u0026#34;: 77} # 新增元素 my_dict[\u0026#34;张信哲\u0026#34;] = 66 print(f\u0026#34;字典经过新增元素后，结果：{my_dict}\u0026#34;) # 更新元素 my_dict[\u0026#34;周杰轮\u0026#34;] = 33 print(f\u0026#34;字典经过更新后，结果：{my_dict}\u0026#34;) # 删除元素 score = my_dict.pop(\u0026#34;周杰轮\u0026#34;) print(f\u0026#34;字典中被移除了一个元素，结果：{my_dict}, 周杰轮的考试分数是：{score}\u0026#34;) # 清空元素, clear my_dict.clear() print(f\u0026#34;字典被清空了，内容是：{my_dict}\u0026#34;) # 获取全部的key my_dict = {\u0026#34;周杰轮\u0026#34;: 99, \u0026#34;林俊节\u0026#34;: 88, \u0026#34;张学油\u0026#34;: 77} keys = my_dict.keys() print(f\u0026#34;字典的全部keys是：{keys}\u0026#34;) # 遍历字典 # 方式1：通过获取到全部的key来完成遍历 for key in keys: print(f\u0026#34;字典的key是:{key}\u0026#34;) print(f\u0026#34;字典的value是：{my_dict[key]}\u0026#34;) # 方式2：直接对字典进行for循环，每一次循环都是直接得到key for key in my_dict: print(f\u0026#34;2字典的key是:{key}\u0026#34;) print(f\u0026#34;2字典的value是：{my_dict[key]}\u0026#34;) # 统计字典内的元素数量, len()函数 num = len(my_dict) print(f\u0026#34;字典中的元素数量有：{num}个\u0026#34;) 5.5.3 字典的特点\n可以容纳多个数据 可以容纳不同类型的数据 每一份数据是KeyValue键值对 可以通过Key获取到Value，Key不可重复（重复会覆盖） 不支持下标索引 可以修改（增加或删除更新元素等） 支持for循环，不支持while循环 5.6 数据容器（序列）的切片 5.6.1 什么是序列\n序列是指：内容连续、有序，可使用下标索引的一类数据容器\n列表、元组、字符串，均可以可以视为序列。\n5.6.2 序列切片\n序列支持切片，即：列表、元组、字符串，均支持进行切片操作\n切片：从一个序列中，取出一个子序列\n语法：序列[起始下标:结束下标:步长] 表示从序列中，从指定位置开始，依次取出元素，到指定位置结束，得到一个新序列：\n起始下标表示从何处开始，可以留空，留空视作从头开始 结束下标（不含）表示何处结束，可以留空，留空视作截取到结尾 步长表示，依次取元素的间隔 步长1表示，一个个取元素 步长2表示，每次跳过1个元素取 步长N表示，每次跳过N-1个元素取 步长为负数表示，反向取（注意，起始下标和结束下标也要反向标记） 注意，此操作不会影响序列本身，而是会得到一个新的序列（列表、元组、字符串）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 # 对list进行切片，从1开始，4结束，步长1 my_list = [0, 1, 2, 3, 4, 5, 6] result1 = my_list[1:4] # 步长默认是1，所以可以省略不写 print(f\u0026#34;结果1：{result1}\u0026#34;) # 对tuple进行切片，从头开始，到最后结束，步长1 my_tuple = (0, 1, 2, 3, 4, 5, 6) result2 = my_tuple[:] # 起始和结束不写表示从头到尾，步长为1可以省略 print(f\u0026#34;结果2：{result2}\u0026#34;) # 对str进行切片，从头开始，到最后结束，步长2 my_str = \u0026#34;01234567\u0026#34; result3 = my_str[::2] print(f\u0026#34;结果3：{result3}\u0026#34;) # 对str进行切片，从头开始，到最后结束，步长-1 my_str = \u0026#34;01234567\u0026#34; result4 = my_str[::-1] # 等同于将序列反转了 print(f\u0026#34;结果4：{result4}\u0026#34;) # 对列表进行切片，从3开始，到1结束，步长-1 my_list = [0, 1, 2, 3, 4, 5, 6] result5 = my_list[3:1:-1] print(f\u0026#34;结果5：{result5}\u0026#34;) # 对元组进行切片，从头开始，到尾结束，步长-2 my_tuple = (0, 1, 2, 3, 4, 5, 6) result6 = my_tuple[::-2] print(f\u0026#34;结果6：{result6}\u0026#34;) 5.7 不同容器对比 列表 元组 字符串 集合 字典 元素数量 支持多个 支持多个 支持多个 支持多个 支持多个 元素类型 任意 任意 仅字符 任意 Key：Value Key：除字典外任意类型 Value：任意类型 下标索引 支持 支持 支持 不支持 不支持 重复元素 支持 支持 支持 不支持 不支持 可修改性 支持 不支持 不支持 支持 支持 数据有序 是 是 是 否 否 使用场景 可修改、可重复的一批数据记录场景 不可修改、可重复的一批数据记录场景 一串字符的记录场景 不可重复的数据记录场景 以Key检索Value的数据记录场景 是否支持下标索引 支持：列表、元组、字符串 - 序列类型 不支持：集合、字典 - 非序列类型 2 . 是否支持重复元素：\n支持：列表、元组、字符串 - 序列类型 不支持：集合、字典 - 非序列类型 3 . 是否可以修改\n支持：列表、集合、字典 不支持：元组、字符串 容器通用功能\n功能 描述 通用for循环 遍历容器（字典是遍历key） max 容器内最大元素 min() 容器内最小元素 len() 容器元素个数 list() 转换为列表 tuple() 转换为元组 str() 转换为字符串 set() 转换为集合 sorted(序列, [reverse=True]) 排序，reverse=True表示降序 得到一个排好序的列表 六. 异常 基本语法\n基本语法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 try: print(name) except NameError as e: print(\u0026#39;name变量名称未定义错误\u0026#39;) # 完整语法 try: f = open(\u0026#34;D:/123.txt\u0026#34;, \u0026#34;r\u0026#34;, encoding=\u0026#34;UTF-8\u0026#34;) except Exception as e: print(\u0026#34;出现异常了\u0026#34;) f = open(\u0026#34;D:/123.txt\u0026#34;, \u0026#34;w\u0026#34;, encoding=\u0026#34;UTF-8\u0026#34;) # else表示的是如果没有异常要执行的代码。 else: print(\u0026#34;好高兴，没有异常。\u0026#34;) # finally表示的是无论是否异常都要执行的代码 finally: print(\u0026#34;我是finally，有没有异常我都要执行\u0026#34;) f.close() 七. Python模块和包 7.1 什么是模块\nPython 模块(Module)，是一个 Python 文件，以 .py 结尾. 模块能定义函数，类和变量，模块里也能包含可执行的代码.\n7.2 模块的作用**:**\npython中有很多各种不同的模块, 每一个模块都可以帮助我们快速的实现一些功能, 比如实现和时间相关的功能就可以使用time模块\n我们可以认为一个模块就是一个工具包, 每一个工具包中都有各种不同的工具供我们使用进而实现各种不同的功能.\n7.3 模块导入\n模块在使用前需要先导入 导入的语法如下:\n常用的组合形式如：\nimport 模块名 from 模块名 import 类、变量、方法等 from 模块名 import * import 模块名 as 别名 from 模块名 import 功能名 as 别名 7.4 __all__变量\n如果一个模块文件中有 __all__变量，当使用 from xxx import * 导入时，只能导入这个列表中的元素\n7.5 什么是包\n从物理上看，包就是一个文件夹，在该文件夹下包含了一个 init.py 文件，该文件夹可用于包含多个模块文件\n**包的作用：**当我们的模块文件越来越多时,包可以帮助我们管理这些模块, 包的作用就是包含多个模块，但包的本质依然是模块\n导入包的语法\nimport 包名.模块名\n包名.模块名.目标\n7.6 python常用包\n科学计算中常用的:numpy包\n数据分析中常用的:pandas包\n大数据计算中常用的:pyspark、apache-flink包\n图形可视化常用的:matplotlib、pyecharts\n人工智能常用的:tensorflow\n","date":"2024-12-27T00:36:30+08:00","permalink":"https://h-yx-blog.github.io/p/python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","title":"Python基础语法"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://h-yx-blog.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu4699868770670889127.jpg","permalink":"https://h-yx-blog.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://h-yx-blog.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu6307248181568134095.jpg","permalink":"https://h-yx-blog.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://h-yx-blog.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu10664154974910995856.jpg","permalink":"https://h-yx-blog.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://h-yx-blog.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://h-yx-blog.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu5876398126655421130.jpg","permalink":"https://h-yx-blog.github.io/p/emoji-support/","title":"Emoji Support"}]